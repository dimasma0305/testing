name: Auto Register Challenges

on:
  push:
    branches:
      - main
      - master
    paths:
      - '**/challenge.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - '**/challenge.yml'
  workflow_dispatch:

jobs:
  register-challenge:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Configure Insecure Registry
        env:
          REGISTRY_URL: ${{ secrets.REGISTRY_URL }}
        if: ${{ env.REGISTRY_URL != '' }}
        run: |
           # Strip protocol if present for daemon.json configuration
           DOMAIN=$(echo "$REGISTRY_URL" | sed -E 's~^https?://~~' | sed 's~/$~~')
           echo "Configuring insecure registry for: $DOMAIN"
           sudo mkdir -p /etc/docker
           # Create or update daemon.json
           if [ -f /etc/docker/daemon.json ]; then
             sudo jq --arg domain "$DOMAIN" '."insecure-registries" += [$domain]' /etc/docker/daemon.json > tmp.json && sudo mv tmp.json /etc/docker/daemon.json
           else
             echo "{\"insecure-registries\": [\"$DOMAIN\"]}" | sudo tee /etc/docker/daemon.json
           fi
           sudo systemctl restart docker

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for commit SHA

      - name: Detect changed challenge files
        id: detect-challenges
        run: |
          echo "challenges<<EOF" >> $GITHUB_OUTPUT
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual trigger - scan entire repository for challenge.yml files
            find . -name "challenge.yml" -not -path '*/.*' | xargs -r -n1 dirname | sort -u >> $GITHUB_OUTPUT
          else
            # Auto-detect from changed files
            git diff --name-only ${{ github.event.before }} ${{ github.sha }} | \
              grep -E 'challenge\.yml$' | \
              xargs -r -n1 dirname | \
              sort -u >> $GITHUB_OUTPUT
          fi
          
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Log in to Registry
        env:
          REGISTRY_URL: ${{ secrets.REGISTRY_URL }}
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "$REGISTRY_URL" ] && [ -n "$REGISTRY_USERNAME" ] && [ -n "$REGISTRY_PASSWORD" ]; then
            echo "Logging in to external registry: $REGISTRY_URL"
            echo "$REGISTRY_PASSWORD" | docker login "$REGISTRY_URL" -u "$REGISTRY_USERNAME" --password-stdin
          else
            echo "Logging in to GHCR"
            echo "$GITHUB_TOKEN" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin
          fi

      - name: Build & push challenge images
        env:
          REGISTRY_URL: ${{ secrets.REGISTRY_URL }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -z "${{ steps.detect-challenges.outputs.challenges }}" ]; then
            echo "No challenges detected to build"
            exit 0
          fi

          COMMIT_SHA="${{ github.sha }}"
          OWNER_REPO="${{ github.repository }}"
          OWNER="${OWNER_REPO%/*}"
          REPO="${OWNER_REPO#*/}"

          # Determine registry base
          # Determine registry base
          # Determine registry base
          if [ -n "$REGISTRY_URL" ]; then
             # Strip trailing slash
             REGISTRY_URL=${REGISTRY_URL%/}
             REGISTRY_BASE="$REGISTRY_URL/${OWNER}/${REPO}"
          else
             REGISTRY_BASE="ghcr.io/${OWNER}/${REPO}"
          fi
          
          # Strip protocol if present
          REGISTRY_BASE=$(echo "$REGISTRY_BASE" | sed -E 's~^https?://~~')
          
          # Convert to lowercase as docker tags must be lowercase
          REGISTRY_BASE=$(echo "$REGISTRY_BASE" | tr '[:upper:]' '[:lower:]')

          echo "${{ steps.detect-challenges.outputs.challenges }}" | while read challenge_dir; do
            [ -z "$challenge_dir" ] && continue

            COMPOSE_FILE=$(grep -E '^compose_file:' "$challenge_dir/challenge.yml" | awk '{print $2}')
            [ -z "$COMPOSE_FILE" ] && COMPOSE_FILE="docker-compose.yml"
            COMPOSE_PATH="$challenge_dir/$COMPOSE_FILE"
            [ -f "$COMPOSE_PATH" ] || { echo "Compose not found: $COMPOSE_PATH"; exit 1; }

            echo "Building services for $challenge_dir using $COMPOSE_PATH"
            services=$(docker compose -f "$COMPOSE_PATH" config --format json | jq -r '.services | to_entries[] | select(.value.build != null) | [.key, (.value.build.context // "."), (.value.build.dockerfile // "Dockerfile")] | @tsv')

            if [ -z "$services" ]; then
              echo "No build services found; skipping build for $challenge_dir"
              continue
            fi

            while IFS=$'\t' read -r svc context dockerfile; do
              # Parse challenge directory to get event, category, challenge_id
              # Expected path format: event/category/challenge_id
              # e.g. demo-event/web/web1
              
              # Split challenge_dir by /
              IFS='/' read -r -a parts <<< "$challenge_dir"
              event_name="${parts[0]}"
              category="${parts[1]}"
              challenge_id="${parts[2]}"
              
              # Construct Image Name: [event]-[category]-[challenge-id]
              image_name="${event_name}-${category}-${challenge_id}"
              
              # If service is not 'web' or 'app' (main service), append it to avoid collision? 
              # User requested specific format. We will stick to it for the image name.
              # But we must tag it. 
              # Tag format: [event]-[category]-[challenge-id]:latest
              
              # REGISTRY_BASE in this context is registry/owner/repo.
              # But we want registry/owner/image_name:latest ??
              # The user said: "tag is formated like this [event_name]-[category]-[challenge-id]:latest"
              # It implies the whole thing is the tag? or image:tag?
              # "web challenge one and two use the same image" implies collision in image name/tag combo.
              
              # Let's assume we maintain the Registry/Owner prefix.
              # And we change the Repository/Image part.
              
              # We need REGISTRY_ROOT/OWNER.
              # REGISTRY_BASE currently contains REPO.
              
              # Extract REGISTRY_ROOT and OWNER from REGISTRY_BASE
              # REGISTRY_BASE = registry/owner/repo
              REGISTRY_ROOT_OWNER="${REGISTRY_BASE%/*}"
              
              # Construct full image reference
              # Use service suffix only if it's not the only one? 
              # To be safe and compliant, let's use the requested format as the IMAGE NAME.
              
              target_image_repo="${REGISTRY_ROOT_OWNER}/${image_name}"
              
              tag="${target_image_repo}:latest"
              
              # docker compose config returns absolute paths
              build_ctx="$context"
              echo "Building ${svc} -> ${tag} (context: ${build_ctx}, dockerfile: ${dockerfile})"
              docker build -f "$build_ctx/$dockerfile" -t "$tag" "$build_ctx"
              echo "Pushing ${tag}"
              docker push "$tag"
            done <<< "$services"
          done

      - name: Register challenges with Challenge Service
        env:
          ORCHESTRATOR_URL: ${{ secrets.ORCHESTRATOR_URL }}
          CHALLENGE_TOKEN: ${{ secrets.CHALLENGE_TOKEN }}
          REGISTRY_URL: ${{ secrets.REGISTRY_URL }}
        run: |
          if [ -z "${{ steps.detect-challenges.outputs.challenges }}" ]; then
            echo "No challenges detected to register"
            exit 0
          fi

          # Strip trailing slash from ORCHESTRATOR_URL
          ORCHESTRATOR_URL=${ORCHESTRATOR_URL%/}

          COMMIT_SHA="${{ github.sha }}"
          REPO_URL="${{ github.server_url }}/${{ github.repository }}"
          OWNER_REPO="${{ github.repository }}"
          OWNER="${OWNER_REPO%/*}"
          REPO="${OWNER_REPO#*/}"

          # Determine registry base
          if [ -n "$REGISTRY_URL" ]; then
             # Strip trailing slash
             REGISTRY_URL=${REGISTRY_URL%/}
             REGISTRY_BASE="$REGISTRY_URL/${OWNER}/${REPO}"
          else
             REGISTRY_BASE="ghcr.io/${OWNER}/${REPO}"
          fi
          
          # Strip protocol if present
          REGISTRY_BASE=$(echo "$REGISTRY_BASE" | sed -E 's~^https?://~~')
          
          # Convert to lowercase
          REGISTRY_BASE=$(echo "$REGISTRY_BASE" | tr '[:upper:]' '[:lower:]')
          
          echo "${{ steps.detect-challenges.outputs.challenges }}" | while read challenge_dir; do
            if [ -z "$challenge_dir" ]; then
              continue
            fi

            echo "Registering challenge from: $challenge_dir"
            
            # Determine compose file from challenge.yml (default docker-compose.yml)
            COMPOSE_FILE=$(grep -E '^compose_file:' "$challenge_dir/challenge.yml" | awk '{print $2}')
            if [ -z "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi

            COMPOSE_PATH="$challenge_dir/$COMPOSE_FILE"

            if [ ! -f "$COMPOSE_PATH" ]; then
              echo "Error: compose file not found for $challenge_dir at $COMPOSE_PATH"
              exit 1
            fi

            # Extract relative path from repo root
            COMPOSE_RELATIVE_PATH=$(echo "$COMPOSE_PATH" | sed "s|^\./||")
            
            # Read compose content
            COMPOSE_CONTENT=$(cat "$COMPOSE_PATH" | jq -sR .)

            # Build JSON payload
            # We need to collect image tags built in previous step.
            
            # Re-parse services to get names
            services=$(docker compose -f "$COMPOSE_PATH" config --format json | jq -r '.services | keys[]')
            
            # Parse challenge directory to get event, category, challenge_id
            IFS='/' read -r -a parts <<< "$challenge_dir"
            event_name="${parts[0]}"
            category="${parts[1]}"
            challenge_id="${parts[2]}"
            
            image_name="${event_name}-${category}-${challenge_id}"
            
            # REGISTRY_BASE = registry/owner/repo
            REGISTRY_ROOT_OWNER="${REGISTRY_BASE%/*}"
            target_image_repo="${REGISTRY_ROOT_OWNER}/${image_name}"
            
            # Construct image_tags JSON object
            IMAGE_TAGS_JSON="{"
            first=true
            
            for svc in $services; do
              tag="${target_image_repo}:latest"
              # We need to map service name to tag
              if [ "$first" = true ]; then
                first=false
              else
                IMAGE_TAGS_JSON="$IMAGE_TAGS_JSON,"
              fi
              IMAGE_TAGS_JSON="$IMAGE_TAGS_JSON \"$svc\": \"$tag\""
            done
            IMAGE_TAGS_JSON="$IMAGE_TAGS_JSON}"

            PAYLOAD=$(cat <<EOF
          {
            "repo": "$REPO_URL",
            "commit": "$COMMIT_SHA",
            "path": "$COMPOSE_RELATIVE_PATH",
            "compose_content": $COMPOSE_CONTENT,
            "image_tags": $IMAGE_TAGS_JSON
          }
          EOF
            )

            echo "Sending registration request to $ORCHESTRATOR_URL/challenges/register"
            # echo "$PAYLOAD" | jq '.' # Debug payload (be careful with large content)

            # Send registration request to challenge service (via gateway)
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "X-Challenge-Token: $CHALLENGE_TOKEN" \
              -d "$PAYLOAD" \
              "$ORCHESTRATOR_URL/challenges/register")

            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
              echo "âœ… Successfully registered challenge: $challenge_dir"
              echo "Response: $BODY"
            else
              echo "âŒ Failed to register challenge: $challenge_dir"
              echo "HTTP Code: $HTTP_CODE"
              echo "Response: $BODY"
              exit 1
            fi
          done

      - name: Create GitHub comment (PR only)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const challenges = `${{ steps.detect-challenges.outputs.challenges }}`.split('\n').filter(Boolean);
            if (challenges.length > 0) {
              const body = `## ðŸš€ Challenge Registration Results
              
              Registered ${challenges.length} challenge(s):
              ${challenges.map(c => `- \`${c}\``).join('\n')}
              
              Commit: \`${{ github.sha }}\``;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

