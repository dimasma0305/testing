name: Auto Register Challenges

on:
  push:
    branches:
      - main
      - master
    paths:
      - '**/challenge.yml'
  pull_request:
    branches:
      - main
      - master
    paths:
      - '**/challenge.yml'
  workflow_dispatch:

jobs:
  register-challenge:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for commit SHA

      - name: Detect changed challenge files
        id: detect-challenges
        run: |
          echo "challenges<<EOF" >> $GITHUB_OUTPUT
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual trigger - scan entire repository for challenge.yml files
            find . -name "challenge.yml" -not -path '*/.*' | xargs -r -n1 dirname | sort -u >> $GITHUB_OUTPUT
          else
            # Auto-detect from changed files
            git diff --name-only ${{ github.event.before }} ${{ github.sha }} | \
              grep -E 'challenge\.yml$' | \
              xargs -r -n1 dirname | \
              sort -u >> $GITHUB_OUTPUT
          fi
          
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Log in to GHCR
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "$GITHUB_TOKEN" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

      - name: Build & push challenge images to GHCR
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -z "${{ steps.detect-challenges.outputs.challenges }}" ]; then
            echo "No challenges detected to build"
            exit 0
          fi

          COMMIT_SHA="${{ github.sha }}"
          OWNER_REPO="${{ github.repository }}"
          OWNER="${OWNER_REPO%/*}"
          REPO="${OWNER_REPO#*/}"

          echo "${{ steps.detect-challenges.outputs.challenges }}" | while read challenge_dir; do
            [ -z "$challenge_dir" ] && continue

            COMPOSE_FILE=$(grep -E '^compose_file:' "$challenge_dir/challenge.yml" | awk '{print $2}')
            [ -z "$COMPOSE_FILE" ] && COMPOSE_FILE="docker-compose.yml"
            COMPOSE_PATH="$challenge_dir/$COMPOSE_FILE"
            [ -f "$COMPOSE_PATH" ] || { echo "Compose not found: $COMPOSE_PATH"; exit 1; }

            echo "Building services for $challenge_dir using $COMPOSE_PATH"
            services=$(docker compose -f "$COMPOSE_PATH" config --format json | jq -r '.services | to_entries[] | select(.value.build != null) | [.key, (.value.build.context // "."), (.value.build.dockerfile // "Dockerfile")] | @tsv')

            if [ -z "$services" ]; then
              echo "No build services found; skipping build for $challenge_dir"
              continue
            fi

            while IFS=$'\t' read -r svc context dockerfile; do
              tag="ghcr.io/${OWNER}/${REPO}-${svc}:${COMMIT_SHA}"
              # docker compose config returns absolute paths
              build_ctx="$context"
              echo "Building ${svc} -> ${tag} (context: ${build_ctx}, dockerfile: ${dockerfile})"
              docker build -f "$build_ctx/$dockerfile" -t "$tag" "$build_ctx"
              echo "Pushing ${tag}"
              docker push "$tag"
            done <<< "$services"
          done

      - name: Register challenges with Challenge Service
        env:
          ORCHESTRATOR_URL: ${{ secrets.ORCHESTRATOR_URL }}
          CHALLENGE_TOKEN: ${{ secrets.CHALLENGE_TOKEN }}
        run: |
          if [ -z "${{ steps.detect-challenges.outputs.challenges }}" ]; then
            echo "No challenges detected to register"
            exit 0
          fi

          COMMIT_SHA="${{ github.sha }}"
          REPO_URL="${{ github.server_url }}/${{ github.repository }}"
          
          echo "${{ steps.detect-challenges.outputs.challenges }}" | while read challenge_dir; do
            if [ -z "$challenge_dir" ]; then
              continue
            fi

            echo "Registering challenge from: $challenge_dir"
            
            # Determine compose file from challenge.yml (default docker-compose.yml)
            COMPOSE_FILE=$(grep -E '^compose_file:' "$challenge_dir/challenge.yml" | awk '{print $2}')
            if [ -z "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi

            COMPOSE_PATH="$challenge_dir/$COMPOSE_FILE"

            if [ ! -f "$COMPOSE_PATH" ]; then
              echo "Error: compose file not found for $challenge_dir at $COMPOSE_PATH"
              exit 1
            fi

            # Extract relative path from repo root
            COMPOSE_RELATIVE_PATH=$(echo "$COMPOSE_PATH" | sed "s|^\./||")
            
            # Read compose content
            COMPOSE_CONTENT=$(cat "$COMPOSE_PATH" | jq -sR .)

            # Build JSON payload
            # We need to collect image tags built in previous step.
            
            # Re-parse services to get names
            services=$(docker compose -f "$COMPOSE_PATH" config --format json | jq -r '.services | keys[]')
            
            # Construct image_tags JSON object
            IMAGE_TAGS_JSON="{"
            first=true
            OWNER_REPO="${{ github.repository }}"
            OWNER="${OWNER_REPO%/*}"
            REPO="${OWNER_REPO#*/}"
            
            for svc in $services; do
              tag="ghcr.io/${OWNER}/${REPO}-${svc}:${COMMIT_SHA}"
              # We need to map service name to tag
              if [ "$first" = true ]; then
                first=false
              else
                IMAGE_TAGS_JSON="$IMAGE_TAGS_JSON,"
              fi
              IMAGE_TAGS_JSON="$IMAGE_TAGS_JSON \"$svc\": \"$tag\""
            done
            IMAGE_TAGS_JSON="$IMAGE_TAGS_JSON}"

            PAYLOAD=$(cat <<EOF
          {
            "repo": "$REPO_URL",
            "commit": "$COMMIT_SHA",
            "path": "$COMPOSE_RELATIVE_PATH",
            "compose_content": $COMPOSE_CONTENT,
            "image_tags": $IMAGE_TAGS_JSON
          }
          EOF
            )

            echo "Sending registration request to $ORCHESTRATOR_URL/challenges/register"
            # echo "$PAYLOAD" | jq '.' # Debug payload (be careful with large content)

            # Send registration request to challenge service (via gateway)
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "X-Challenge-Token: $CHALLENGE_TOKEN" \
              -d "$PAYLOAD" \
              "$ORCHESTRATOR_URL/challenges/register")

            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
              echo "âœ… Successfully registered challenge: $challenge_dir"
              echo "Response: $BODY"
            else
              echo "âŒ Failed to register challenge: $challenge_dir"
              echo "HTTP Code: $HTTP_CODE"
              echo "Response: $BODY"
              exit 1
            fi
          done

      - name: Create GitHub comment (PR only)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const challenges = `${{ steps.detect-challenges.outputs.challenges }}`.split('\n').filter(Boolean);
            if (challenges.length > 0) {
              const body = `## ðŸš€ Challenge Registration Results
              
              Registered ${challenges.length} challenge(s):
              ${challenges.map(c => `- \`${c}\``).join('\n')}
              
              Commit: \`${{ github.sha }}\``;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

